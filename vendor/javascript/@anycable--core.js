// @anycable/core@1.1.4 downloaded from https://ga.jspm.io/npm:@anycable/core@1.1.4/index.js

import{createNanoEvents as e}from"nanoevents";class ReasonError extends Error{constructor(e,t){if(e instanceof Error){super(e.message);this.cause=e}else super(e);this.reason=t;this.name="ReasonError"}}class SubscriptionRejectedError extends ReasonError{constructor(e){super("Rejected",e);this.name="SubscriptionRejectedError"}}class SubscriptionTimeoutError extends ReasonError{constructor(e){super(e||"Timed out to receive subscription ack");this.name="SubscriptionTimeoutError"}}class DisconnectedError extends ReasonError{constructor(e,t){t?super(e,t):super("Disconnected",e);this.name="DisconnectedError"}}class CommandError extends Error{constructor(e){super(e);this.name="CommandError"}}class StaleConnectionError extends DisconnectedError{constructor(e){super(e,"stale_connection");this.name="StaleConnectionError"}}function t(e){if(!e)return"";let t=Object.keys(e).sort().filter((t=>e[t]!==void 0)).map((t=>{let s=JSON.stringify(e[t]);return`${JSON.stringify(t)}:${s}`}));return`{${t.join(",")}}`}class Presence{constructor(e){this.channel=e;this.listeners=[]}watch(){this.listeners.push(this.channel.on("presence",(e=>{e.type!=="info"?this._state&&(e.type==="join"?this._state[e.id]=e.info:e.type==="leave"&&delete this._state[e.id]):this._state||(this._state=this.stateFromInfo(e))})))}reset(){delete this._state}dispose(){delete this._info;delete this._state;this.listeners.forEach((e=>e()));this.listeners.length=0}async join(e,t){if(!this._info){this._info={id:e,info:t};return this.channel.perform("$presence:join",this._info)}}async leave(){if(!this._info)return;let e=await this.channel.perform("$presence:leave");delete this._info;return e}async info(){if(this._state)return this._state;this._promise||(this._promise=this._sync());await this._promise;return this._state}async _sync(){this.watch();try{let e=await this.channel.perform("$presence:info",{});this._state=this.stateFromInfo(e);return this._state}finally{delete this._promise}}stateFromInfo(e){return e.records.reduce(((e,{id:t,info:s})=>{e[t]=s;return e}),{})}}const s=Symbol("state");class Channel{constructor(t={}){this.emitter=e();this.params=Object.freeze(t);this.presence=new Presence(this);this.initialConnect=true;this[s]="idle"}get identifier(){if(this._identifier)return this._identifier;this._identifier=t({channel:this.channelId,...this.params});return this._identifier}get channelId(){return this.constructor.identifier}get state(){return this[s]}attached(e){if(this.receiver){if(this.receiver!==e)throw Error("Already connected to a different receiver");return false}this.receiver=e;return true}connecting(){this[s]="connecting"}connected(){if(this.state==="connected")return;if(this.state==="closed")return;this[s]="connected";let e=false;if(this.initialConnect){this.initialConnect=false;this.emit("connect",{reconnect:false,restored:e})}else this.emit("connect",{reconnect:true,restored:e})}restored(){if(this.state==="connected")throw Error("Already connected");this[s]="connected";let e=true;let t=true;this.initialConnect=false;this.emit("connect",{reconnect:t,restored:e})}disconnected(e){if(this.state!=="disconnected"&&this.state!=="closed"){this[s]="disconnected";this.presence.reset();this.emit("disconnect",e)}}closed(e){if(this.state!=="closed"){this[s]="closed";delete this.receiver;this.initialConnect=true;this.presence.dispose();this.emit("close",e)}}disconnect(){this.state!=="idle"&&this.state!=="closed"&&this.receiver.unsubscribe(this)}async perform(e,t){if(this.state==="idle"||this.state==="closed")throw Error("Channel is not subscribed");return this.receiver.perform(this.identifier,e,t)}async send(e){return this.perform(void 0,e)}async whisper(e){try{await this.perform("$whisper",e)}catch(e){let t=this.receiver?this.receiver.logger:null;t&&t.warn("whisper failed: ",e)}}receive(e,t){this.emit("message",e,t)}on(e,t){return this.emitter.on(e,t)}once(e,t){let s=this.emitter.on(e,((...e)=>{s();t(...e)}));return s}emit(e,...t){return this.emitter.emit(e,...t)}ensureSubscribed(){return this.state==="connected"?Promise.resolve():this.state==="closed"?Promise.reject(Error("Channel is unsubscribed")):this.pendingSubscribe()}pendingSubscribe(){if(this._pendingSubscribe)return this._pendingSubscribe;this._pendingSubscribe=new Promise(((e,t)=>{let s=[()=>delete this._pendingSubscribe];s.push(this.on("connect",(()=>{s.forEach((e=>e()));e()})));s.push(this.on("close",(e=>{s.forEach((e=>e()));t(e||new ReasonError("Channel was disconnected before subscribing","canceled"))})))}));return this._pendingSubscribe}}class Subscription{constructor(e){this.id=e;this.intent="unsubscribed";this.state="idle";this.channels=[];this.disposed=false;this._pendings=[]}add(e){this.channels.includes(e)||this.channels.push(e)}remove(e){let t=this.channels.indexOf(e);t>-1&&this.channels.splice(t,1)}notify(e,...t){this.state=e==="restored"?"connected":e;t.length===1?this.channels.forEach((s=>s[e](t[0]))):this.channels.forEach((t=>t[e]()))}pending(e){this._checkIntent(e);let t=this._pendings[0];return t&&t.intent===e?t.promise:Promise.resolve()}ensureResubscribed(){if(!this.disposed){this.intent=void 0;this.ensureSubscribed()}}ensureSubscribed(){if(this.intent==="subscribed")return;if(this.disposed)throw Error("Subscription is disposed");this.intent="subscribed";let e=this._mergeWithPending("unsubscribed");e||this.subscriber(this)}maybeUnsubscribe(){if(this.disposed)return;if(this.intent==="unsubscribed")return;if(this.channels.length>0)return;this.intent="unsubscribed";let e=this._mergeWithPending("subscribed");e||this.unsubscriber(this)}async acquire(e){this._checkIntent(e);let t;let s=new Promise((e=>{t=e}));let i={promise:s,intent:e,release:()=>{this._pendings.splice(this._pendings.indexOf(i),1);t(i)},canceled:false,acquired:false};let n=this._pendingTop;this._pendings.push(i);n&&await n.promise;this.gvl&&await this.gvl.acquire(i,e);i.acquired=true;return i}close(e){this.disposed=true;this.intent=void 0;this.notify("closed",e)}_checkIntent(e){if(e!=="unsubscribed"&&e!=="subscribed")throw Error(`Unknown subscription intent: ${e}`)}get _pendingTop(){return this._pendings.length?this._pendings[this._pendings.length-1]:void 0}_mergeWithPending(e){let t=this._pendingTop;if(!t)return false;if(t.acquired)return false;if(t.intent!==e)return false;this._pendings.pop();t.canceled=true;return true}}class GlobalLock{constructor(){this.queue=[]}async acquire(e,t){if(t==="subscribed"){this.queue.push(e.promise.then((()=>{this.queue.splice(this.queue.indexOf(e),1)})));this.queue.length>1&&await this.queue[this.queue.length-2]}}}class Subscriptions{constructor(e){e.concurrentSubscribes===false&&(this.glv=new GlobalLock);this._subscriptions={};this._localToRemote={}}all(){return Object.values(this._subscriptions)}get(e){return this._subscriptions[e]}create(e,{subscribe:t,unsubscribe:s}){let i=this._subscriptions[e]=new Subscription(e);i.remoteId=this._localToRemote[e];i.subscriber=t;i.unsubscriber=s;i.gvl=this.glv;return i}remove(e){delete this._subscriptions[e];delete this._localToRemote[e]}storeRemoteId(e,t){this._localToRemote[e]=t;let s=this.get(e);s&&(s.remoteId=t)}}class Hub{constructor(e={}){this.subscriptions=new Subscriptions(e);this._pendingMessages=[];this._remoteToLocal={}}subscribe(e,t){this._remoteToLocal[t]=e;this.subscriptions.storeRemoteId(e,t);this.flush(t)}unsubscribe(e){let t=this.subscriptions.get(e);if(!t)return;let s=t.remoteId;s&&delete this._remoteToLocal[s];this.subscriptions.remove(e)}transmit(e,t,s){let i=this._remoteToLocal[e];if(!i){this._pendingMessages.push([e,t,s]);return}let n=this.subscriptions.get(i);n&&n.channels.forEach((e=>{e.receive(t,s)}))}notify(e,t,s){let i=this._remoteToLocal[e];if(!i)return;let n=this.subscriptions.get(i);n&&n.channels.forEach((e=>e.emit(t,s)))}close(){this._pendingMessages.length=0}get size(){return this.channels.length}get channels(){return this.subscriptions.all().flatMap((e=>e.channels))}flush(e){let t=[];for(let s of this._pendingMessages)s[0]===e?this.transmit(s[0],s[1],s[2]):t.push(s);this._pendingMessages=t}}const i={debug:0,info:1,warn:2,error:3};class BaseLogger{constructor(e){this.level=e||"warn"}log(e,t,s){i[e]<i[this.level]||this.writeLogEntry(e,t,s)}writeLogEntry(){throw Error("Not implemented")}debug(e,t){this.log("debug",e,t)}info(e,t){this.log("info",e,t)}warn(e,t){this.log("warn",e,t)}error(e,t){this.log("error",e,t)}}class NoopLogger extends BaseLogger{writeLogEntry(){}}class JSONEncoder{encode(e){return JSON.stringify(e)}decode(e){try{return JSON.parse(e)}catch(e){}}}let n=0;class ActionCableProtocol{constructor(e={}){let{logger:t}=e;this.logger=t||new NoopLogger;this.pendingSubscriptions={};this.pendingUnsubscriptions={};this.subscribeCooldownInterval=e.subscribeCooldownInterval||250;this.subscribeRetryInterval=e.subscribeRetryInterval||5e3}attached(e){this.cable=e}subscribe(e,s){let i={channel:e};s&&Object.assign(i,s);let r=t(i);if(this.pendingUnsubscriptions[r]){let t=this.subscribeCooldownInterval*1.5;this.logger.debug(`unsubscribed recently, cooldown for ${t}`,r);return new Promise((i=>{setTimeout((()=>{i(this.subscribe(e,s))}),t)}))}if(this.pendingSubscriptions[r]){this.logger.warn("subscription is already pending, skipping",r);return Promise.reject(Error("Already subscribing"))}let o=this.subscribeRetryInterval;return new Promise(((e,t)=>{let s=++n;this.pendingSubscriptions[r]={resolve:e,reject:t,id:s};this.cable.send(this.buildSubscribeRequest(r));this.maybeRetrySubscribe(s,r,o)}))}buildSubscribeRequest(e){return{command:"subscribe",identifier:e}}maybeRetrySubscribe(e,t,s){setTimeout((()=>{let i=this.pendingSubscriptions[t];if(i&&i.id===e){this.logger.warn(`no subscription ack received in ${s}ms, retrying subscribe`,t);this.cable.send(this.buildSubscribeRequest(t));this.maybeExpireSubscribe(e,t,s)}}),s)}maybeExpireSubscribe(e,t,s){setTimeout((()=>{let i=this.pendingSubscriptions[t];if(i&&i.id===e){delete this.pendingSubscriptions[t];i.reject(new SubscriptionTimeoutError(`Haven't received subscription ack in ${s*2}ms for ${t}`))}}),s)}unsubscribe(e){this.cable.send({command:"unsubscribe",identifier:e});this.pendingUnsubscriptions[e]=true;setTimeout((()=>{delete this.pendingUnsubscriptions[e]}),this.subscribeCooldownInterval);return Promise.resolve()}perform(e,t,s){if(t==="$whisper")return this.whisper(e,s);s||(s={});s.action||=t;this.cable.send({command:"message",identifier:e,data:JSON.stringify(s)});return Promise.resolve()}whisper(e,t){this.cable.send({command:"whisper",identifier:e,data:t});return Promise.resolve()}receive(e){if(typeof e!=="object"){this.logger.error("unsupported message format",{message:e});return}let{type:t,identifier:s,message:i,reason:n,reconnect:r}=e;if(t==="ping")return this.cable.keepalive(e.message);this.cable.keepalive();if(t==="welcome"){let t=e.sid;t&&this.cable.setSessionId(t);return this.cable.connected()}if(t!=="disconnect"){if(t==="confirm_subscription"){let e=this.pendingSubscriptions[s];if(!e){this.logger.error("subscription not found, unsubscribing",{type:t,identifier:s});this.unsubscribe(s);return}delete this.pendingSubscriptions[s];return e.resolve(s)}if(t==="reject_subscription"){let e=this.pendingSubscriptions[s];if(!e)return this.logger.error("subscription not found",{type:t,identifier:s});delete this.pendingSubscriptions[s];return e.reject(new SubscriptionRejectedError)}if(i)return{identifier:s,message:i};this.logger.warn(`unknown message type: ${t}`,{message:e})}else{let e=new DisconnectedError(n);this.reset(e);r===false?this.cable.closed(e):this.cable.disconnected(e)}}reset(e){for(let t in this.pendingSubscriptions)this.pendingSubscriptions[t].reject(e);this.pendingSubscriptions={}}recoverableClosure(){return false}}const r=()=>Date.now()/1e3|0;class ActionCableExtendedProtocol extends ActionCableProtocol{constructor(e={}){super(e);this.streamsPositions={};this.subscriptionStreams={};this.pendingHistory={};this.pendingPresence={};this.presenceInfo={};this.restoreSince=e.historyTimestamp;this.disableSessionRecovery=e.disableSessionRecovery;this.restoreSince===void 0&&(this.restoreSince=r());this.sessionId=void 0;this.sendPongs=e.pongs}reset(e){for(let t in this.pendingPresence)this.pendingPresence[t].reject(e);this.pendingPresence={};return super.reset()}receive(e){if(typeof e!=="object"){this.logger.error("unsupported message format",{message:e});return}let{type:t,identifier:s,message:i}=e;if(t==="disconnect"){delete this.sessionId;this.cable.setSessionId("");return super.receive(e)}if(t==="reject_subscription")return super.receive(e);if(t==="confirm_subscription"){this.subscriptionStreams[s]||(this.subscriptionStreams[s]=new Set);return super.receive(e)}if(t==="ping"){!this.restoreSince===false&&(this.restoreSince=r());this.sendPongs&&this.sendPong();return this.cable.keepalive(e.message)}this.cable.keepalive();if(t!=="confirm_history")if(t!=="reject_history"){if(t==="welcome"){if(!this.disableSessionRecovery){this.sessionId=e.sid;this.sessionId&&this.cable.setSessionId(this.sessionId)}if(e.restored){let t=e.restored_ids||Object.keys(this.subscriptionStreams);for(let e of t){this.cable.send({identifier:e,command:"history",history:this.historyRequestFor(e)});this.presenceInfo[e]&&this.cable.send({identifier:e,command:"join",presence:this.presenceInfo[e]})}return this.cable.restored(t)}return this.cable.connected(this.sessionId)}if(t==="presence"){let e=i.type;if(e==="info"){let e=this.pendingPresence[s];if(e){delete this.pendingPresence[s];e.resolve(i)}}else if(e==="error"){let e=this.pendingPresence[s];if(e){delete this.pendingPresence[s];e.reject(new Error("failed to retrieve presence"))}}return{type:t,identifier:s,message:i}}if(i){let t=this.trackStreamPosition(s,e.stream_id,e.epoch,e.offset);return{identifier:s,message:i,meta:t}}this.logger.warn(`unknown message type: ${t}`,{message:e})}else{this.logger.warn("failed to retrieve history",e);this.cable.notify("history_not_found",s)}else{this.logger.debug("history result received",e);this.cable.notify("history_received",s)}}perform(e,t,s){switch(t){case"$presence:join":return this.join(e,s);case"$presence:leave":return this.leave(e,s);case"$presence:info":return this.presence(e,s)}return super.perform(e,t,s)}unsubscribe(e){delete this.presenceInfo[e];return super.unsubscribe(e)}buildSubscribeRequest(e){let t=super.buildSubscribeRequest(e);let s=this.historyRequestFor(e);if(s){t.history=s;this.pendingHistory[e]=true}let i=this.presenceInfo[e];i&&(t.presence=i);return t}recoverableClosure(){return!!this.sessionId}historyRequestFor(e){let t={};let s=false;if(this.subscriptionStreams[e])for(let i of this.subscriptionStreams[e]){let e=this.streamsPositions[i];if(e){s=true;t[i]=e}}if(s||this.restoreSince)return{since:this.restoreSince,streams:t}}trackStreamPosition(e,t,s,i){if(t&&s){this.subscriptionStreams[e]||(this.subscriptionStreams[e]=new Set);this.subscriptionStreams[e].add(t);this.streamsPositions[t]={epoch:s,offset:i};return{stream:t,epoch:s,offset:i}}}async sendPong(){await new Promise((e=>setTimeout(e,0)));this.cable.state==="connected"&&this.cable.send({command:"pong"})}async join(e,t){this.presenceInfo[e]=t;this.cable.send({command:"join",identifier:e,presence:t});return Promise.resolve()}async leave(e,t){delete this.presenceInfo[e];this.cable.send({command:"leave",identifier:e,presence:t});return Promise.resolve()}presence(e,t){if(this.pendingPresence[e]){this.logger.warn("presence is already pending, skipping",e);return Promise.reject(Error("presence request is already pending"))}return new Promise(((s,i)=>{this.pendingPresence[e]={resolve:s,reject:i};this.cable.send({command:"presence",identifier:e,data:t})}))}}class NoConnectionError extends ReasonError{constructor(){super("No connection","closed");this.name="NoConnectionError"}}class GhostChannel extends Channel{static identifier="__ghost__";constructor(e,t){super(t);this.channelId=e}set channelId(e){this._channelId=e}get channelId(){return this._channelId}}const o="$pubsub";class PubSubChannel extends Channel{static identifier=o;async perform(e,t){if(e.startsWith("$"))return super.perform(e,t);throw Error("not implemented")}}const c=Symbol("state");class Cable{constructor({transport:t,protocol:s,encoder:i,logger:n,lazy:r,hubOptions:o,performFailures:h,transportConfigurator:a}){this.emitter=e();this.transport=t;this.encoder=i;this.logger=n||new NoopLogger;this.protocol=s;this.performFailures=h||"throw";this.protocol.attached(this);this.hub=new Hub(o||{});this[c]="idle";this.handleClose=this.handleClose.bind(this);this.handleIncoming=this.handleIncoming.bind(this);this.transportConfigurator=a;this.transport.on("close",this.handleClose);this.transport.on("data",this.handleIncoming);this.initialConnect=true;this.recovering=false;r===false&&this.connect().catch((()=>{}))}get state(){return this[c]}async connect(){if(this.state==="connected")return Promise.resolve();if(this.state==="connecting")return this.pendingConnect();let e=this.state==="idle";this[c]="connecting";let t=this.pendingConnect();this.logger.debug("connecting");try{this.transportConfigurator&&await this.transportConfigurator(this.transport,{initial:e});await this.transport.open()}catch(e){this.handleClose(e)}return t}setSessionId(e){this.sessionId=e;this.transport.setParam("sid",e)}connected(){if(this.state==="connected")return;this.logger.info("connected");this[c]="connected";this.recovering&&this.hub.subscriptions.all().forEach((e=>e.notify("disconnected",new DisconnectedError("recovery_failed"))));this.hub.subscriptions.all().forEach((e=>this._resubscribe(e)));let e=false;this.recovering=false;if(this.initialConnect){this.initialConnect=false;this.emit("connect",{reconnect:false,restored:e})}else this.emit("connect",{reconnect:true,restored:e})}restored(e){this.logger.info("connection recovered",{remoteIds:e});this[c]="connected";this.hub.subscriptions.all().forEach((t=>{if(e&&t.remoteId&&e.includes(t.remoteId))t.notify("restored");else{t.notify("disconnected",new DisconnectedError("recovery_failed"));this._resubscribe(t)}}));let t=!this.initialConnect;let s=true;this.recovering=false;this.initialConnect=false;this.emit("connect",{reconnect:t,restored:s})}notify(e,t,s){if(t&&typeof t!=="string"){s=t;t=void 0}t?this.hub.notify(t,"info",{type:e,data:s}):this.emit("info",{type:e,data:s})}handleClose(e){this.logger.debug("transport closed",{error:e});this.disconnected(new DisconnectedError(e,"transport_closed"))}disconnected(e){if(this.state==="connected"||this.state==="connecting"){this.logger.info("disconnected",{reason:e});this[c]="disconnected";this.recovering=this.protocol.recoverableClosure(e);this.recovering?this.hub.subscriptions.all().forEach((e=>e.notify("connecting"))):this.hub.subscriptions.all().forEach((t=>{t.notify("disconnected",e)}));this.protocol.reset(e);this.hub.close();this.transport.close();this.emit("disconnect",e)}}closed(e){if(this.state==="closed"||this.state==="idle")return;let t;e&&(t=e instanceof DisconnectedError?e:new DisconnectedError(e,void 0));this.logger.info("closed",{reason:e||"user"});this[c]="closed";let s=t||new DisconnectedError("cable_closed");this.hub.subscriptions.all().forEach((e=>e.notify("disconnected",s)));this.hub.close();this.protocol.reset();this.transport.close();this.initialConnect=true;this.emit("close",t)}disconnect(){this.closed()}handleIncoming(e){if(this.state==="closed"||this.state==="idle")return;let t=this.encoder.decode(e);if(t===void 0){this.logger.error("failed to decode message",{message:e});return}this.logger.debug("incoming data",t);let s=this.protocol.receive(t);if(s){this.logger.debug("processed incoming message",s);let{type:e,identifier:t,message:i,meta:n}=s;e?this.hub.notify(t,e,i):this.hub.transmit(t,i,n)}}send(e){if(this.state==="closed")throw Error("Cable is closed");let t=this.encoder.encode(e);if(t!==void 0){this.logger.debug("outgoing message",e);this.transport.send(t)}else this.logger.error("failed to encode message",{message:e})}keepalive(e){this.emit("keepalive",e)}streamFrom(e){let t=new PubSubChannel({stream_name:e});return this.subscribe(t)}streamFromSigned(e){let t=new PubSubChannel({signed_stream_name:e});return this.subscribe(t)}subscribeTo(e,t){let s;let i;if(typeof e==="string"){i=e;e=GhostChannel}s=i?new e(i,t):new e(t);return this.subscribe(s)}subscribe(e){if(!e.attached(this))return e;let t=e.identifier;e.connecting();let s=this.hub.subscriptions.get(t)||this.hub.subscriptions.create(t,{subscribe:t=>this._subscribe(t,e.channelId,e.params),unsubscribe:e=>this._unsubscribe(e)});s.add(e);s.intent==="subscribed"&&s.state==="connected"&&e.connected();s.ensureSubscribed();return e}async _resubscribe(e){if(e.intent!=="subscribed")return;let t=e.channels[0];if(t){e.notify("connecting");e.ensureResubscribed()}}async _subscribe(e,t,s){let i=e.id;this.state==="idle"&&this.connect().catch((()=>{}));if(this.state!=="connected"){this.logger.debug("cancel subscribe, no connection",{identifier:i});return}this.logger.debug("acquiring subscribe lock",{identifier:i});let n=await e.acquire("subscribed");if(n.canceled){this.logger.debug("subscribe lock has been canceled",{identifier:i});n.release();return}this.logger.debug("subscribe lock has been acquired",{identifier:i});if(e.intent!=="subscribed"){this.logger.debug("cancel subscribe request, already unsubscribed");n.release();return}if(this.state!=="connected"){this.logger.debug("cancel subscribe, no connection",{identifier:i});n.release();return}if(e.state==="connected"){this.logger.debug("already connected, skip subscribe command",{identifier:i});e.notify("connected");n.release();return}let r={identifier:t,params:s};this.logger.debug("subscribing",r);try{let n=await this.protocol.subscribe(t,s);this.hub.subscribe(i,n);this.logger.debug("subscribed",{...r,remoteId:n});e.notify("connected")}catch(t){if(t){t instanceof SubscriptionRejectedError&&this.logger.warn("rejected",r);if(t instanceof DisconnectedError){this.logger.debug("disconnected during subscription; will retry on connect",r);n.release();return}this.logger.error("failed to subscribe",{error:t,...r})}e.close(t);this.hub.unsubscribe(i)}n.release()}unsubscribe(e){let t=e.identifier;let s=this.hub.subscriptions.get(t);if(!s)throw Error(`Subscription not found: ${t}`);s.remove(e);e.closed();s.maybeUnsubscribe()}async _unsubscribe(e){let t=e.id;this.logger.debug("acquiring unsubscribe lock",{identifier:t});let s=await e.acquire("unsubscribed");if(s.canceled){this.logger.debug("unsubscribe lock has been canceled",{identifier:t});s.release();return}this.logger.debug("unsubscribe lock has been acquired",{identifier:t});if(e.intent!=="unsubscribed"){this.logger.debug("cancel unsubscribe, no longer needed",{identifier:t,intent:e.intent});s.release();return}if(e.state==="disconnected"||e.state==="closed"){this.logger.debug(`already ${e.state} connected, skip unsubscribe command`,{identifier:t});s.release();return}let i=e.remoteId;this.logger.debug("unsubscribing...",{remoteId:i});if(this.state==="connected"){try{await this.protocol.unsubscribe(i);this.logger.debug("unsubscribed remotely",{id:t})}catch(e){e&&(e instanceof DisconnectedError?this.logger.debug("cable disconnected during the unsubscribe command execution",{id:t,error:e}):this.logger.error("unsubscribe failed",{id:t,error:e}))}if(e.intent==="unsubscribed"){e.close();this.hub.unsubscribe(t)}else e.state="closed";s.release()}else{this.logger.debug("unsubscribe skipped (cable is not connected)",{id:t});e.close();this.hub.unsubscribe(t);s.release()}}async perform(e,t,s){if(this.performFailures==="throw")return this._perform(e,t,s);try{return await this._perform(e,t,s)}catch(e){this.performFailures==="warn"&&this.logger.warn("perform failed",{error:e});return}}async _perform(e,t,s){this.state==="connecting"&&await this.pendingConnect();if(this.state==="closed"||this.state==="disconnected")throw new NoConnectionError;let i=this.hub.subscriptions.get(e);if(!i)throw Error(`Subscription not found: ${e}`);await i.pending("subscribed");if(i.intent!=="subscribed")throw Error(`Subscription is closed: ${e}`);let n=i.remoteId;let r={id:n,action:t,payload:s};this.logger.debug("perform",r);try{let e=await this.protocol.perform(n,t,s);e&&this.logger.debug("perform result",{message:e,request:r});return e}catch(e){this.logger.error("perform failed",{error:e,request:r});throw e}}on(e,t){return this.emitter.on(e,t)}once(e,t){let s=this.emitter.on(e,((...e)=>{s();t(...e)}));return s}emit(e,...t){return this.emitter.emit(e,...t)}pendingConnect(){if(this._pendingConnect)return this._pendingConnect;this._pendingConnect=new Promise(((e,t)=>{let s=[()=>delete this._pendingConnect];s.push(this.on("connect",(()=>{s.forEach((e=>e()));e()})));s.push(this.on("close",(e=>{s.forEach((e=>e()));t(e)})));s.push(this.on("disconnect",(e=>{s.forEach((e=>e()));t(e)})))}));return this._pendingConnect}}const h={maxMissingPings:2,maxReconnectAttempts:Infinity};const a=()=>Date.now();const l=(e,t)=>{t=t||{};let{backoffRate:s,jitterRatio:i,maxInterval:n}=t;s=s||2;i===void 0&&(i=.5);return t=>{let r=e*s**t;let o=r*s;let c=r+(o-r)*Math.random();let h=2*(Math.random()-.5)*i;c*=1+h;n&&n<c&&(c=n);return c}};class Monitor{constructor({pingInterval:e,...t}){this.pingInterval=e;if(!this.pingInterval)throw Error(`Incorrect pingInterval is provided: ${e}`);t=Object.assign({},h,t);this.strategy=t.reconnectStrategy;if(!this.strategy)throw Error("Reconnect strategy must be provided");this.maxMissingPings=t.maxMissingPings;this.maxReconnectAttempts=t.maxReconnectAttempts;this.logger=t.logger||new NoopLogger;this.state="pending_connect";this.attempts=0;this.disconnectedAt=a()}watch(e){this.target=e;this.initListeners()}reconnectNow(){if(this.state==="connected"||this.state==="pending_connect"||this.state==="closed")return false;this.cancelReconnect();this.state="pending_connect";this.target.connect().catch((e=>{this.logger.info("Failed at reconnecting: "+e)}));return true}initListeners(){this.unbind=[];this.unbind.push(this.target.on("connect",(()=>{this.attempts=0;this.pingedAt=a();this.state="connected";this.cancelReconnect();this.startPolling()})));this.unbind.push(this.target.on("disconnect",(()=>{this.disconnectedAt=a();this.state="disconnected";this.stopPolling();this.scheduleReconnect()})));this.unbind.push(this.target.on("close",(()=>{this.disconnectedAt=a();this.state="closed";this.cancelReconnect();this.stopPolling()})));this.unbind.push(this.target.on("keepalive",(()=>{this.pingedAt=a()})));this.unbind.push((()=>{this.cancelReconnect();this.stopPolling()}))}dispose(){delete this.target;this.unbind&&this.unbind.forEach((e=>e()));delete this.unbind}startPolling(){this.pollId&&clearTimeout(this.pollId);let e=this.pingInterval+(Math.random()-.5)*this.pingInterval*.5;this.pollId=setTimeout((()=>{this.checkStale();this.state==="connected"&&this.startPolling()}),e)}stopPolling(){this.pollId&&clearTimeout(this.pollId)}checkStale(){let e=a()-this.pingedAt;if(e>this.maxMissingPings*this.pingInterval){this.logger.warn(`Stale connection: ${e}ms without pings`);this.state="pending_disconnect";this.target.disconnected(new StaleConnectionError)}}scheduleReconnect(){if(this.attempts>=this.maxReconnectAttempts){this.target.close();return}let e=this.strategy(this.attempts);this.attempts++;this.logger.info(`Reconnecting in ${e}ms (${this.attempts} attempt)`);this.state="pending_reconnect";this.reconnnectId=setTimeout((()=>this.reconnectNow()),e)}cancelReconnect(){if(this.reconnnectId){clearTimeout(this.reconnnectId);delete this.reconnnectId}}}class FallbackTransport{constructor(t,s={}){this.transports=t;this.transport=null;this.emitter=e();this.unbind=[];this.logger=s.logger||new NoopLogger}displayName(){return"fallbacked transport"}async open(){for(let e=0;e<this.transports.length;e++){let t=this.transports[e];try{this.transport=t;this.resetListeners();this.logger.debug(`Trying to connect via ${t.displayName()}`);await t.open();this.logger.debug(`Connected via ${t.displayName()}`);return}catch(e){this.logger.debug(`Failed to connect via ${t.displayName()}: ${e.message}`)}}this.transport=null;this.resetListeners();throw new Error("Couldn't connect via any available transport")}send(e){if(!this.transport)throw new Error("No transport is open");this.transport.send(e)}async close(){if(!this.transport)throw new Error("No transport is open");await this.transport.close();this.transport=null}setURL(){throw new Error("Not implemented. Set URL for each transport separately")}setParam(e,t){this.transports.forEach((s=>{s.setParam(e,t)}))}setToken(e,t){this.transports.forEach((s=>{s.setToken(e,t)}))}on(e,t){return this.emitter.on(e,t)}once(e,t){let s=this.emitter.on(e,((...e)=>{s();t(...e)}));return s}get url(){return this.transport?this.transport.url:""}resetListeners(){this.unbind.forEach((e=>e()));this.unbind.length=0;this.transport&&this.unbind.push(this.transport.on("open",(()=>{this.emitter.emit("open")})),this.transport.on("data",(e=>{this.emitter.emit("data",e)})),this.transport.on("close",(e=>{this.emitter.emit("close",e)})),this.transport.on("error",(e=>{this.emitter.emit("error",e)})))}}class WebSocketTransport{constructor(t,s={}){this.url=t;let i=s.websocketImplementation;if(i)this.Impl=i;else{if(typeof WebSocket==="undefined")throw new Error("No WebSocket support");this.Impl=WebSocket}this.connected=false;this.emitter=e();let{format:n,subprotocol:r,authStrategy:o}=s;this.format=n||"text";this.connectionOptions=s.websocketOptions;this.authStrategy=o||"param";this.authProtocol="";this.subprotocol=r}displayName(){return"WebSocket("+this.url+")"}open(){let e=this.subprotocol;this.authStrategy==="sub-protocol"&&(e=[this.subprotocol,this.authProtocol]);this.connectionOptions?this.ws=new this.Impl(this.url,e,this.connectionOptions):this.ws=new this.Impl(this.url,e);this.ws.binaryType="arraybuffer";this.initListeners();return new Promise(((e,t)=>{let s=[];s.push(this.once("open",(()=>{s.forEach((e=>e()));e()})));s.push(this.once("close",(()=>{s.forEach((e=>e()));t(Error("WS connection closed"))})))}))}setURL(e){this.url=e}setParam(e,t){let s=new URL(this.url);s.searchParams.set(e,t);let i=`${s.protocol}//${s.host}${s.pathname}?${s.searchParams}`;this.setURL(i)}setToken(e,t="jid"){if(this.authStrategy==="param")this.setParam(t,e);else if(this.authStrategy==="header"){this.connectionOptions=this.connectionOptions||{};this.connectionOptions.headers=this.connectionOptions.headers||{};let s=`x-${t}`.toLowerCase();let i=Object.keys(this.connectionOptions.headers).find((e=>e.toLowerCase()===s));s=i||s;this.connectionOptions.headers[s]=e}else{if(this.authStrategy!=="sub-protocol")throw new Error("Unknown auth strategy: "+this.authStrategy);this.authProtocol=`anycable-token.${e}`}}send(e){if(!this.ws||!this.connected)throw Error("WebSocket is not connected");this.ws.send(e)}close(){this.ws?this.onclose():this.connected=false}on(e,t){return this.emitter.on(e,t)}once(e,t){let s=this.emitter.on(e,((...e)=>{s();t(...e)}));return s}initListeners(){this.ws.onerror=e=>{this.connected&&this.emitter.emit("error",e.error||new Error("WS Error"))};this.ws.onclose=()=>{this.onclose()};this.ws.onmessage=e=>{let t=e.data;this.format==="binary"&&(t=new Uint8Array(t));this.emitter.emit("data",t)};this.ws.onopen=()=>{this.connected=true;this.emitter.emit("open")}}onclose(){this.ws.onclose=void 0;this.ws.onmessage=void 0;this.ws.onopen=void 0;this.ws.close();delete this.ws;this.connected=false;this.emitter.emit("close")}}class ActionCableSubscription{constructor(e){this.channel=e}notify(e,...t){typeof this[e]==="function"&&this[e](...t)}perform(e,t={}){this.channel.perform(e,t)}send(e){this.channel.send(e)}whisper(e){return this.channel.whisper(e)}get identifier(){return this.channel.identifier}unsubscribe(){return this.channel.disconnect()}}class ActionCableChannel extends GhostChannel{constructor(e,t,s){super(e,t);this.subscription=new ActionCableSubscription(this);Object.assign(this.subscription,s);this.on("connect",(({reconnect:e})=>this.subscription.notify("connected",{reconnected:e})));this.on("disconnect",(()=>this.subscription.notify("disconnected",{allowReconnect:true})));this.on("message",(e=>this.subscription.notify("received",e)));this.on("close",(e=>{e&&e instanceof SubscriptionRejectedError?this.subscription.notify("rejected"):this.subscription.notify("disconnected",{allowReconnect:false})}))}}class ActionCableSubscriptions{constructor(e){this.cable=e}create(e,t){let s;let i;if(typeof e==="object"){s=e.channel;delete e.channel;i=e}else{s=e;i={}}let n=new ActionCableChannel(s,i,t);n.subscription.notify("initialized");this.cable.subscribe(n);return n.subscription}findAll(e){return this.cable.hub.channels.filter((t=>t.identifier===e)).map((e=>e.subscription))}}class ActionCableConsumer{constructor(e){this.cable=e;this.subscriptions=new ActionCableSubscriptions(e)}send(e){return this.cable.send(e)}connect(){return this.cable.connect()}disconnect(){return this.cable.disconnect()}ensureActiveConnection(){return this.cable.connect()}}const u={protocol:"actioncable-v1-json",pingInterval:3e3,maxReconnectAttempts:Infinity,maxMissingPings:2,logLevel:"warn",lazy:true};function d(e,t){if(typeof e==="object"&&typeof t==="undefined"){t=e;e=void 0}t=t||{};if(!e&&!t.transport)throw Error("URL or transport must be specified");t=Object.assign({},u,t);let{protocol:s,websocketImplementation:i,websocketFormat:n,websocketOptions:r,websocketAuthStrategy:o,fallbacks:c,logLevel:h,logger:a,transport:d,encoder:p,lazy:g,monitor:f,pingInterval:m,reconnectStrategy:w,maxMissingPings:y,maxReconnectAttempts:S,subprotocol:v,tokenRefresher:_,historyTimestamp:E,protocolOptions:C,concurrentSubscribes:I,performFailures:P,transportConfigurator:k,auth:R}=t;a=a||new NoopLogger(h);if(typeof s==="string"){v=v||s;let e=s.substring(0,s.lastIndexOf("-"));let t=s.substring(s.lastIndexOf("-")+1);C=C||{};if(e==="actioncable-v1")s=new ActionCableProtocol({logger:a,...C});else{if(e!=="actioncable-v1-ext")throw Error(`Protocol is not supported yet: ${s}`);s=new ActionCableExtendedProtocol({logger:a,historyTimestamp:E,...C})}if(t==="json"){p=p||new JSONEncoder;n=n||"text"}else if(t==="msgpack"){n="binary";if(!p)throw Error("Msgpack encoder must be specified explicitly. Use `@anycable/msgpack-encoder` package or build your own")}else{if(t!=="protobuf")throw Error(`Protocol is not supported yet: ${s}`);n=n||"binary";if(!p)throw Error("Protobuf encoder must be specified explicitly. Use `@anycable/protobuf-encoder` package or build your own")}}if(!s)throw Error("Protocol must be specified");d=d||new WebSocketTransport(e,{websocketImplementation:i,websocketOptions:r,subprotocol:v,authStrategy:o,format:n});c&&(d=new FallbackTransport([d,...c],{logger:a}));R&&R.token&&d.setToken(R.token,R.param||"jid");w=w||l(m);f!==false&&(f=f||new Monitor({pingInterval:m,reconnectStrategy:w,maxMissingPings:y,maxReconnectAttempts:S,logger:a}));let j={concurrentSubscribes:I};let x=new Cable({protocol:s,transport:d,encoder:p,logger:a,lazy:g,hubOptions:j,performFailures:P,transportConfigurator:k});if(f){f.watch(x);x.monitor=f}_&&b(x,(async()=>{try{await _(d)}catch(e){a.error("Failed to refresh authentication token: "+e);return false}x.connect().catch((()=>{}));return true}));return x}function b(e,t){let s=false;e.on("connect",(()=>s=false));e.on("close",(async i=>{if(i)if(s)e.logger.warn("Token auto-refresh is disabled",i);else if(i.reason==="token_expired"){s=true;await t()}}))}function p(e,t){let s=d(e,t);return new ActionCableConsumer(s)}export{ActionCableConsumer,ActionCableExtendedProtocol,ActionCableProtocol,ActionCableSubscription,ActionCableSubscriptions,BaseLogger,Cable,Channel,CommandError,u as DEFAULT_OPTIONS,DisconnectedError,FallbackTransport,Hub,JSONEncoder,Monitor,NoConnectionError,NoopLogger,ReasonError,StaleConnectionError,Subscription,SubscriptionRejectedError,SubscriptionTimeoutError,Subscriptions,WebSocketTransport,l as backoffWithJitter,d as createCable,p as createConsumer,t as stringifyParams};

